Found cargo project: rsheet
Located autotests for rsheet
6991 cargo build --target-dir target # crate.tar
   Compiling proc-macro2 v1.0.79
   Compiling unicode-ident v1.0.12
   Compiling libc v0.2.153
   Compiling crunchy v0.2.2
   Compiling quote v1.0.36
   Compiling syn v2.0.58
   Compiling serde v1.0.197
   Compiling version_check v0.9.4
   Compiling autocfg v1.2.0
   Compiling tiny-keccak v2.0.2
   Compiling memchr v2.7.2
   Compiling cfg-if v1.0.0
   Compiling getrandom v0.2.14
   Compiling aho-corasick v1.1.3
   Compiling serde_derive v1.0.197
   Compiling once_cell v1.19.0
   Compiling regex-syntax v0.8.3
   Compiling utf8parse v0.2.1
   Compiling anstyle-parse v0.2.3
   Compiling regex-automata v0.4.6
   Compiling const-random-macro v0.1.16
   Compiling num-traits v0.2.18
   Compiling smartstring v1.0.1
   Compiling ahash v0.8.11
   Compiling colorchoice v1.0.0
   Compiling anstyle-query v1.0.2
   Compiling anstyle v1.0.6
   Compiling anstream v0.6.13
   Compiling regex v1.10.4
   Compiling const-random v0.1.18
   Compiling zerocopy v0.7.32
   Compiling static_assertions v1.1.0
   Compiling serde_json v1.0.115
   Compiling thin-vec v0.2.13
   Compiling smallvec v1.13.2
   Compiling rhai_codegen v2.0.0
   Compiling ryu v1.0.17
   Compiling bitflags v2.5.0
   Compiling strsim v0.11.1
   Compiling clap_lex v0.7.0
   Compiling itoa v1.0.11
   Compiling log v0.4.21
   Compiling heck v0.5.0
   Compiling env_filter v0.1.0
   Compiling clap_derive v4.5.4
   Compiling rhai v1.17.1
   Compiling clap_builder v4.5.2
   Compiling humantime v2.1.0
   Compiling env_logger v0.11.3
   Compiling clap v4.5.4
   Compiling rsheet_lib v0.1.3
   Compiling rsheet v0.1.0 (/tmp/tmp5goqhzxa/autotest)
    Finished dev [unoptimized + debuginfo] target(s) in 28.30s
Test test_01_01_simplest_test_cases (simplest_test_cases #01) - passed
Test test_01_02_simplest_test_cases (simplest_test_cases #02) - passed
Test test_01_03_simplest_test_cases (simplest_test_cases #03) - passed
Test test_01_04_simplest_test_cases (simplest_test_cases #04) - passed
Test test_01_05_simplest_test_cases (simplest_test_cases #05) - passed
Test test_01_06_simplest_test_cases (simplest_test_cases #06) - passed
Test test_01_07_simplest_test_cases (simplest_test_cases #07) - passed
Test test_01_08_simplest_test_cases (simplest_test_cases #08) - passed
Test test_01_09_simplest_test_cases (simplest_test_cases #09) - passed
Test test_01_10_simplest_test_cases (simplest_test_cases #10) - passed
Test test_02_01_simple_calculations (simple_calculations #01) - passed
Test test_02_02_simple_calculations (simple_calculations #02) - passed
Test test_02_03_simple_calculations (simple_calculations #03) - passed
Test test_02_04_simple_calculations (simple_calculations #04) - passed
Test test_02_05_simple_calculations (simple_calculations #05) - failed (Incorrect output)
Your program produced this line of output:
Error (hidden by mark mode)

The correct 1 lines of output for this test were:
A1 = Error (hidden by mark mode)

The difference between your output(-) and the correct output(+) is:
- Error (hidden by mark mode)
+ A1 = Error (hidden by mark mode)
? +++++


The input for this test was:
set A1 asdf-not-a-command
get A1
Note: last character in above input is not '\n'

You can reproduce this test by executing these commands:
  6991 cargo build --target-dir target # crate.tar
  echo -n -e 'set A1 asdf-not-a-command\nget A1' | ./target/debug/rsheet --mark-mode
Test test_02_06_simple_calculations (simple_calculations #06) - failed (Incorrect output)
Your program produced these 2 lines of output:
Error (hidden by mark mode)
A7 = "test"

The correct 2 lines of output for this test were:
A6 = Error (hidden by mark mode)
A7 = "test"

The difference between your output(-) and the correct output(+) is:
- Error (hidden by mark mode)
+ A6 = Error (hidden by mark mode)
? +++++

...

The input for this test was:
set A7 "test"
set A6 silly-error
get A6
get A7
Note: last character in above input is not '\n'

You can reproduce this test by executing these commands:
  6991 cargo build --target-dir target # crate.tar
  echo -n -e 'set A7 "test"\nset A6 silly-error\nget A6\nget A7' | ./target/debug/rsheet --mark-mode
Test test_03_01_simple_references (simple_references #01) - passed
Test test_03_02_simple_references (simple_references #02) - passed
Test test_03_03_simple_references (simple_references #03) - passed
Test test_03_04_simple_references (simple_references #04) - passed
Test test_03_05_simple_references (simple_references #05) - passed
Test test_03_06_simple_references (simple_references #06) - failed (Incorrect output)
Your program produced these 2 lines of output:
Error (hidden by mark mode)
A2 = "Circular dependency detected"

The correct 2 lines of output for this test were:
A1 = Error (hidden by mark mode)
Error (hidden by mark mode)

The difference between your output(-) and the correct output(+) is:
+ A1 = Error (hidden by mark mode)
  Error (hidden by mark mode)
- A2 = "Circular dependency detected"

The input for this test was:
set A1 error-this-isn't real code
set A2 A1
get A1
get A2
Note: last character in above input is not '\n'

You can reproduce this test by executing these commands:
  6991 cargo build --target-dir target # crate.tar
  echo -n -e 'set A1 error-this-isn'"'"'t real code\nset A2 A1\nget A1\nget A2' | ./target/debug/rsheet --mark-mode
Test test_04_01_vectors_and_matricies (vectors_and_matricies #01) - passed
Test test_04_02_vectors_and_matricies (vectors_and_matricies #02) - passed
Test test_04_03_vectors_and_matricies (vectors_and_matricies #03) - passed
Test test_04_04_vectors_and_matricies (vectors_and_matricies #04) - passed
Test test_05_01_multiple_readers (multiple_readers #01) - failed (Incorrect output)
Your program produced this line of output:
A1 = None

The correct 1 lines of output for this test were:
A1 = 3

The difference between your output(-) and the correct output(+) is:
- A1 = None
+ A1 = 3

The input for this test was:
a: set A1 3
b: set A2 sleep_then(100, 1)
b: get A1
Note: last character in above input is not '\n'

You can reproduce this test by executing these commands:
  6991 cargo build --target-dir target # crate.tar
  echo -n -e 'a: set A1 3\nb: set A2 sleep_then(100, 1)\nb: get A1' | ./target/debug/rsheet --mark-mode
Test test_05_02_multiple_readers (multiple_readers #02) - passed
Test test_06_01_one-level_dependency_changes (one-level_dependency_changes #01) - passed
Test test_06_02_one-level_dependency_changes (one-level_dependency_changes #02) - passed
Test test_06_03_one-level_dependency_changes (one-level_dependency_changes #03) - passed
Test test_06_04_one-level_dependency_changes (one-level_dependency_changes #04) - passed
Test test_06_05_one-level_dependency_changes (one-level_dependency_changes #05) - failed (Incorrect output)
Your program produced these 2 lines of output:
Error (hidden by mark mode)
A2 = 10

The correct 2 lines of output for this test were:
A2 = 8
A2 = 10

The difference between your output(-) and the correct output(+) is:
- Error (hidden by mark mode)
+ A2 = 8
  A2 = 10

The input for this test was:
a: set A1 1
b: set A2 sleep_then(100, A1 + 7)
b: get A2
c: sleep 200
c: set A1 3
c: sleep 200
c: get A2
Note: last character in above input is not '\n'

You can reproduce this test by executing these commands:
  6991 cargo build --target-dir target # crate.tar
  echo -n -e 'a: set A1 1\nb: set A2 sleep_then(100, A1 + 7)\nb: get A2\nc: sleep 200\nc: set A1 3\nc: sleep 200\nc: get A2' | ./target/debug/rsheet --mark-mode
Test test_07_01_vector-matrix_dep_changes (vector-matrix_dep_changes #01) - passed
Test test_07_02_vector-matrix_dep_changes (vector-matrix_dep_changes #02) - passed
Test test_07_03_vector-matrix_dep_changes (vector-matrix_dep_changes #03) - passed
Test test_07_04_vector-matrix_dep_changes (vector-matrix_dep_changes #04) - passed
Test test_08_01_multi-layered_deps (multi-layered_deps #01) - passed
Test test_08_02_multi-layered_deps (multi-layered_deps #02) - passed
Test test_08_03_multi-layered_deps (multi-layered_deps #03) - passed
Test test_08_04_multi-layered_deps (multi-layered_deps #04) - passed
Test test_08_05_multi-layered_deps (multi-layered_deps #05) - failed (Incorrect output)
Your program produced these 4 lines of output:
A3 = 11
C3 = 10
C1 = 11
D4 = 56

The correct 4 lines of output for this test were:
A3 = 11
C3 = 10
C1 = 11
D4 = 32

The difference between your output(-) and the correct output(+) is:
...
  C1 = 11
- D4 = 56
+ D4 = 32

The input for this test was:
a: set A1 5
a: sleep 100
a: set A2 A1 + 1
a: set A3 A1 + A2
b: set B1 A1 + 1
b: set C1 B1 + A1
c: set B2 A1
c: set C3 2 * B2
d: sleep 250
d: get A3
d: get C3
d: get C1
d: set A1 9
d: set D4 C3 + C1 + A3
e: sleep 600
e: get D4
Note: last character in above input is not '\n'

You can reproduce this test by executing these commands:
  6991 cargo build --target-dir target # crate.tar
  echo -n -e 'a: set A1 5\na: sleep 100\na: set A2 A1 + 1\na: set A3 A1 + A2\nb: set B1 A1 + 1\nb: set C1 B1 + A1\nc: set B2 A1\nc: set C3 2 * B2\nd: sleep 250\nd: get A3\nd: get C3\nd: get C1\nd: set A1 9\nd: set D4 C3 + C1 + A3\ne: sleep 600\ne: get D4' | ./target/debug/rsheet --mark-mode
Test test_09_01_circular_deps (circular_deps #01) - failed (Incorrect output)
Your program produced these 2 lines of output:
A1 = "Circular dependency detected"
A2 = "Circular dependency detected"

The correct 2 lines of output for this test were:
Error (hidden by mark mode)
Error (hidden by mark mode)

The difference between your output(-) and the correct output(+) is:
- A1 = "Circular dependency detected"
- A2 = "Circular dependency detected"
+ Error (hidden by mark mode)
+ Error (hidden by mark mode)

The input for this test was:
set A1 A2
set A2 A1
get A1
get A2
Note: last character in above input is not '\n'

You can reproduce this test by executing these commands:
  6991 cargo build --target-dir target # crate.tar
  echo -n -e 'set A1 A2\nset A2 A1\nget A1\nget A2' | ./target/debug/rsheet --mark-mode
Test test_09_02_circular_deps (circular_deps #02) - passed
Test test_09_03_circular_deps (circular_deps #03) - failed (Incorrect output)
Your program produced this line of output:
A1 = "Circular dependency detected"

The correct 1 lines of output for this test were:
Error (hidden by mark mode)

The difference between your output(-) and the correct output(+) is:
- A1 = "Circular dependency detected"
+ Error (hidden by mark mode)

The input for this test was:
A: set A1 A2
B: sleep 100
B: set A2 A1
C: sleep 200
C: get A1
Note: last character in above input is not '\n'

You can reproduce this test by executing these commands:
  6991 cargo build --target-dir target # crate.tar
  echo -n -e 'A: set A1 A2\nB: sleep 100\nB: set A2 A1\nC: sleep 200\nC: get A1' | ./target/debug/rsheet --mark-mode
Test test_09_04_circular_deps (circular_deps #04) - failed (Incorrect output)
Your program produced this line of output:
A1 = "Circular dependency detected"

The correct 1 lines of output for this test were:
Error (hidden by mark mode)

The difference between your output(-) and the correct output(+) is:
- A1 = "Circular dependency detected"
+ Error (hidden by mark mode)

The input for this test was:
A: set A1 A2
B: set A2 A1
C: sleep 200
C: get A1
Note: last character in above input is not '\n'

You can reproduce this test by executing these commands:
  6991 cargo build --target-dir target # crate.tar
  echo -n -e 'A: set A1 A2\nB: set A2 A1\nC: sleep 200\nC: get A1' | ./target/debug/rsheet --mark-mode
37 tests passed 9 tests failed



use log::info;
use rsheet_lib::cell_value::CellValue;
use rsheet_lib::cells::{column_name_to_number, column_number_to_name};
use rsheet_lib::command_runner::{CellArgument, CommandRunner};
use rsheet_lib::connect::{Manager, Reader, Writer};
use rsheet_lib::replies::Reply;
use std::collections::{HashMap, HashSet};
use std::error::Error;
use std::sync::{Arc, Mutex};

// contains the expressions Hashmap
struct Coordinator {
    expressions: Mutex<HashMap<String, String>>,
}

impl Coordinator {
    // make a new one
    fn new() -> Self {
        Coordinator {
            expressions: Mutex::new(HashMap::new()),
        }
    }

    // lock expressions and add the expression
    // visited is for circular dependencies
    fn get_cell(&self, cell_name: &str) -> Result<CellValue, String> {
        let expressions = self.expressions.lock().unwrap();
        let mut visited = HashSet::new();
        calculate_cell_value(&expressions, cell_name, &mut visited)
    }

    // lock expressions
    fn set_cell(&self, cell_name: &str, expression: &str) {
        let mut expressions = self.expressions.lock().unwrap();
        expressions.insert(cell_name.to_string(), expression.to_string());
    }
}

fn handle_connection<R, W>(
    mut recv: R,
    mut send: W,
    coordinator: Arc<Coordinator>,
) -> Result<(), Box<dyn Error>>
where
    R: Reader,
    W: Writer,
{
    loop {
        info!("Just got message");
        let msg = recv.read_message()?;
        let parts: Vec<&str> = msg.trim().splitn(2, ' ').collect();

        match parts[0] {
            "get" => {
                if parts.len() != 2 {
                    send.write_message(Reply::Error(
                        "Invalid get command: Missing cell name".to_string(),
                    ))?;
                } else {
                    let cell_name = parts[1];
                    match coordinator.get_cell(cell_name) {
                        Ok(value) => {
                            send.write_message(Reply::Value(cell_name.to_string(), value))?
                        }
                        Err(e) => send.write_message(Reply::Error(e))?,
                    }
                }
            }
            "set" => {
                if parts.len() != 2 {
                    send.write_message(Reply::Error(
                        "Invalid set command: Missing cell name or expression".to_string(),
                    ))?;
                } else {
                    let mut parts = parts[1].splitn(2, ' ');
                    let cell_name = parts.next().unwrap();
                    let expression = parts.next().unwrap_or("");
                    if expression.is_empty() {
                        send.write_message(Reply::Error(
                            "Invalid set command: Missing expression".to_string(),
                        ))?;
                    } else {
                        coordinator.set_cell(cell_name, expression);
                    }
                }
            }
            _ => send.write_message(Reply::Error("Invalid command".to_string()))?,
        };
    }
}

fn get_vector_value(
    cells: &HashMap<String, CellValue>,
    col_start: u32,
    row_start: u32,
    col_end: u32,
    row_end: u32,
) -> Vec<CellValue> {
    if col_start == col_end {
        (row_start..=row_end)
            .map(|row| get_cell_value(cells, col_start, row))
            .collect()
    } else {
        (col_start..=col_end)
            .map(|col| get_cell_value(cells, col, row_start))
            .collect()
    }
}

fn get_matrix_value(
    cells: &HashMap<String, CellValue>,
    col_start: u32,
    row_start: u32,
    col_end: u32,
    row_end: u32,
) -> Vec<Vec<CellValue>> {
    (row_start..=row_end)
        .map(|row| {
            (col_start..=col_end)
                .map(|col| get_cell_value(cells, col, row))
                .collect()
        })
        .collect()
}

fn get_cell_value(cells: &HashMap<String, CellValue>, col: u32, row: u32) -> CellValue {
    let cell_name = format!("{}{}", column_number_to_name(col), row);
    cells.get(&cell_name).cloned().unwrap_or(CellValue::None)
}

fn calculate_variables(
    expressions: &HashMap<String, String>,
    expression: &str,
    visited: &mut HashSet<String>,
) -> Result<HashMap<String, CellArgument>, String> {
    let command_runner = CommandRunner::new(expression);
    let variables = command_runner.find_variables();

    variables
        .into_iter()
        .map(|var_name| {
            let cell_argument = if var_name.contains('_')
                && !var_name.contains("sum")
                && !var_name.contains("sleep")
            {
                let parts: Vec<&str> = var_name.split('_').collect();
                if parts.len() != 2 {
                    return Err(format!("Invalid cell range: {}", var_name));
                }

                let start_col = parts[0]
                    .chars()
                    .take_while(|c| c.is_alphabetic())
                    .collect::<String>();
                let start_row = parts[0][start_col.len()..]
                    .parse::<u32>()
                    .map_err(|_| format!("Invalid cell range: {}", var_name))?;
                let end_col = parts[1]
                    .chars()
                    .take_while(|c| c.is_alphabetic())
                    .collect::<String>();
                let end_row = parts[1][end_col.len()..]
                    .parse::<u32>()
                    .map_err(|_| format!("Invalid cell range: {}", var_name))?;

                let col_start = column_name_to_number(&start_col);
                let col_end = column_name_to_number(&end_col);

                let cells = expressions
                    .iter()
                    .map(|(name, _)| {
                        (
                            name.clone(),
                            calculate_cell_value(expressions, name, visited).unwrap_or(
                                CellValue::Error("Circular dependency detected".to_string()),
                            ),
                        )
                    })
                    .collect();

                if col_start == col_end || start_row == end_row {
                    let value = get_vector_value(&cells, col_start, start_row, col_end, end_row);
                    CellArgument::Vector(value)
                } else {
                    let value = get_matrix_value(&cells, col_start, start_row, col_end, end_row);
                    CellArgument::Matrix(value)
                }
            } else {
                let value = calculate_cell_value(expressions, &var_name, visited)
                    .unwrap_or(CellValue::Error("Circular dependency detected".to_string()));
                CellArgument::Value(value)
            };

            Ok((var_name.clone(), cell_argument))
        })
        .collect()
}

fn calculate_cell_value(
    expressions: &HashMap<String, String>,
    cell_name: &str,
    visited: &mut HashSet<String>,
) -> Result<CellValue, String> {
    if !cell_name.chars().all(|c| c.is_alphanumeric()) {
        return Err(format!("Invalid cell name: {}", cell_name));
    }

    if visited.contains(cell_name) {
        return Err("Circular dependency detected".to_string());
    }

    if let Some(expression) = expressions.get(cell_name) {
        visited.insert(cell_name.to_string());
        let variables = calculate_variables(expressions, expression, visited)?;
        visited.remove(cell_name);

        let command_runner = CommandRunner::new(expression);
        match command_runner.run(&variables) {
            CellValue::Error(e) => Err(e),
            value => Ok(value),
        }
    } else {
        Ok(CellValue::None)
    }
}

pub fn start_server<M>(mut manager: M) -> Result<(), Box<dyn Error>>
where
    M: Manager,
{
    let coordinator = Arc::new(Coordinator::new());

    std::thread::scope(|s| loop {
        if let Ok((recv, send)) = manager.accept_new_connection() {
            let coordinator = coordinator.clone();

            s.spawn(move || {
                let _ = handle_connection(recv, send, coordinator);
            });
        } else {
            return Ok(());
        }
    })
}
